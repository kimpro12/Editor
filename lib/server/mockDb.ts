import type { Box, Dataset, DatasetDetail, DatasetStatus } from "@/types/ingestion";
import JSZip from "jszip";

type Stored = DatasetDetail & {
  finalize_done_at?: number;
};

type StorageObject = { bytes: Uint8Array; contentType: string };

class MockDB {
  datasetsByUser = new Map<string, Map<string, Stored>>();
  storage = new Map<string, StorageObject>();

  getUserDatasets(userId: string) {
    let map = this.datasetsByUser.get(userId);
    if (!map) {
      map = new Map();
      this.datasetsByUser.set(userId, map);
    }
    return map;
  }

  list(userId: string): { items: Dataset[] } {
    const map = this.getUserDatasets(userId);
    const items = Array.from(map.values()).map((d) => this.normalize(d));
    items.sort((a, b) => (a.updated_at < b.updated_at ? 1 : -1));
    return { items };
  }

  get(userId: string, id: string): DatasetDetail | null {
    const map = this.getUserDatasets(userId);
    const d = map.get(id);
    if (!d) return null;

    // simulate finalize completion
    if (d.status === "FINALIZING" && d.finalize_done_at && Date.now() >= d.finalize_done_at) {
      d.status = "DONE";
      d.updated_at = new Date().toISOString();
    }
    return this.normalize(d, true);
  }

  create(userId: string, input: { name: string; asset_type: string; token?: string }): Dataset {
    const map = this.getUserDatasets(userId);
    const id = crypto.randomUUID();
    const now = new Date().toISOString();
    const d: Stored = {
      id,
      name: input.name,
      asset_type: input.asset_type,
      status: "DRAFT",
      updated_at: now,
      token: input.token,
      boxes: [],
    };
    map.set(id, d);
    return this.normalize(d);
  }

  setRaw(userId: string, datasetId: string, key: string) {
    const map = this.getUserDatasets(userId);
    const d = map.get(datasetId);
    if (!d) return;
    d.raw_key = key;
    d.preview_key = key;
    d.status = "PREVIEW_READY";
    d.updated_at = new Date().toISOString();
  }

  setBoxes(userId: string, datasetId: string, boxes: Box[]) {
    const map = this.getUserDatasets(userId);
    const d = map.get(datasetId);
    if (!d) return;
    d.boxes = boxes;
    d.updated_at = new Date().toISOString();
  }

  async finalize(userId: string, datasetId: string, boxes: Box[], dedupe: boolean) {
    const map = this.getUserDatasets(userId);
    const d = map.get(datasetId);
    if (!d) throw new Error("dataset not found");

    d.status = "FINALIZING";
    d.updated_at = new Date().toISOString();
    d.finalize_done_at = Date.now() + 1500;

    const export_key = `exports/${userId}/${datasetId}/dataset.zip`;
    const manifest_key = `exports/${userId}/${datasetId}/manifest.json`;

    d.export_key = export_key;
    d.manifest_key = manifest_key;

    const manifest = {
      dataset_id: datasetId,
      user_id: userId,
      exported_at: new Date().toISOString(),
      dedupe,
      boxes: boxes.map((b) => ({
        id: b.id,
        x: b.x,
        y: b.y,
        w: b.w,
        h: b.h,
        caption: b.caption ?? "",
        ignore_warning: !!b.ignore_warning,
        qc_warnings: b.qc_warnings ?? [],
      })),
    };

    // store manifest json
    const manifestBytes = new TextEncoder().encode(JSON.stringify(manifest, null, 2));
    this.storage.set(manifest_key, { bytes: manifestBytes, contentType: "application/json" });

    // make zip with manifest + placeholders
    const zip = new JSZip();
    zip.file("manifest.json", JSON.stringify(manifest, null, 2));
    zip.file("README.txt", "Mock export generated by ingestion-frontend BFF.\n");
    const zipBytes = await zip.generateAsync({ type: "uint8array" });

    this.storage.set(export_key, { bytes: zipBytes, contentType: "application/zip" });

    return { export_key, manifest_key, status: d.status as DatasetStatus };
  }

  putObject(key: string, bytes: Uint8Array, contentType: string) {
    this.storage.set(key, { bytes, contentType });
  }

  getObject(key: string): StorageObject | null {
    return this.storage.get(key) ?? null;
  }

  normalize(d: Stored, includeBoxes = false): any {
    const base: any = {
      id: d.id,
      name: d.name,
      asset_type: d.asset_type,
      status: d.status,
      updated_at: d.updated_at,
      token: d.token,
      raw_key: d.raw_key,
      preview_key: d.preview_key,
      export_key: d.export_key,
      manifest_key: d.manifest_key,
    };
    if (includeBoxes) base.boxes = d.boxes ?? [];
    return base;
  }
}

declare global {
  // eslint-disable-next-line no-var
  var __mockdb__: MockDB | undefined;
}

export const mockdb = globalThis.__mockdb__ ?? new MockDB();
globalThis.__mockdb__ = mockdb;
